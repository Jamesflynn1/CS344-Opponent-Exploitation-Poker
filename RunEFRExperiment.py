# Copyright 2019 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Example use of the CFR algorithm on Kuhn Poker."""
import pandas as pd
import time
import sys


import EFR
from open_spiel.python.algorithms import exploitability
from open_spiel.python.algorithms import cfr

import StoreTabularPolicy
import pyspiel

FL_game = 'leduc_poker'
FL_iterations = 100
FL_players = 2
FL_print_freq = 1
FL_Runname = "Test run"
FL_deviation = "cfps"
try:
  FL_Runname = sys.argv[1]
except:
  pass
try:
  FL_iterations = int(sys.argv[2])
  print(FL_iterations)
except:
  pass
try:
  FL_deviation = sys.argv[3]
except:
  pass

header = ['Iteration', 'Execution Time', 'Exploitability']#, 'Average Payoff', 'Value compared to uniform']
cfr_data = []
efr_data = []


def main():
  game = pyspiel.load_game(FL_game, {"players": FL_players})
  efr_solver = EFR.EFRSolver(game, FL_deviation)
  cfr_solver = cfr.CFRSolver(game)

  for i in range(FL_iterations):
    cfr_iteration_data = [i]
    EFR_iteration_data = [i]

    EFR_t = time.process_time()
    efr_solver.evaluate_and_update_policy()
    EFR_t = time.process_time() - EFR_t

    CFR_t = time.process_time()
    cfr_solver.evaluate_and_update_policy()
    CFR_t = time.process_time() - CFR_t

    EFR_iteration_data.append(EFR_t)
    cfr_iteration_data.append(CFR_t)
    efr_regrets = efr_solver.return_cumulative_regret()
    cfr_regrets = cfr_solver.return_cumulative_regret()

    max_regret_difference = 0

    if i % FL_print_freq == 0:
      conv = exploitability.exploitability(game, efr_solver.average_policy())
      print("EFR Iteration {} exploitability {}".format(i, conv))
      #value = expected_game_score.policy_value(game.new_initial_state(),efr_solver.average_policy())
      #print ("EFR Policy Value : {}".format(value))
      EFR_iteration_data.append(conv)

      cconv = exploitability.exploitability(game, cfr_solver.average_policy())
      print("CFR Iteration {} exploitability {}".format(i, cconv))

      cfr_iteration_data.append(cconv)
    for index in range(len(cfr_regrets.keys())):
      infoset = list(cfr_regrets.keys())[index]
      #print(cfr_regrets[infoset].keys())
      #print(efr_regrets[infoset].keys())
      for actions in range(len(cfr_regrets[infoset].keys())):
        action = list(cfr_regrets[infoset].keys())[actions]
        #print( list(cfr_regrets[infoset].keys())[actions] == list(efr_regrets[infoset].keys())[actions])
        #print (cfr_regrets[infoset][action] - efr_regrets[infoset][action])
        max_regret_difference = max(cfr_regrets[infoset][action] - efr_regrets[infoset][action], max_regret_difference)
        #if cfr_regrets[infoset][action] - efr_regrets[infoset][action] == 0.0:
          #print(str(infoset) + "********************" + str(action))
        #else:
           #print(str(infoset)+ str(action))
    cfr_data.append(cfr_iteration_data)
    efr_data.append(EFR_iteration_data)
    print ("##########################################")


  CFR_data = pd.DataFrame(cfr_data, columns=header)
  EFR_data = pd.DataFrame(efr_data, columns=header)
  EFR_data.to_csv(FL_Runname+'EFR.csv', index=False)
  CFR_data.to_csv(FL_Runname+'CFR.csv', index=False)
  StoreTabularPolicy.save_tabular_policy("Policy/"+FL_Runname+".csv", efr_solver.average_policy())
  stored_policy = StoreTabularPolicy.load_tabular_policy("Policy/"+FL_Runname+".csv", game)
  conv = exploitability.exploitability(game, stored_policy)

  print(conv)
main()