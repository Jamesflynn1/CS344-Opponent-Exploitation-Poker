from Deviation_Types.Deviation import *
import attr
import numpy as np
from Deviation_Types.Swap_Transform import LocalSwapTransform 

def return_blind_action(num_actions, history, prior_legal_actions):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_informed_action(num_actions, history, prior_legal_actions):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_CF(num_actions, history, prior_legal_actions):
    memory_weights = [None]
    prior_actions_in_memory = np.zeros(len(history))
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_informed_CF(num_actions, history, prior_legal_actions):
    memory_weights = [None]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    memory_weights = [None]
    print(history)
    if len(history)>0:
        memory_weights.append(np.ones(len(history)))
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cf_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    memory_weights = [None]
    if len(history)>0:
        memory_weights.append(np.ones(len(history)))
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cs_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    external_memory_weights = [None]

    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        external_memory_weights.append(possible_memory_weight)

    external = return_all_external_modified_deviations(num_actions, external_memory_weights, prior_legal_actions,prior_actions_in_memory, history)
    internal = return_blind_action(num_actions, history, None)

    cf_ext = return_informed_CF(num_actions, history, None)
    cf_int = return_blind_CF(num_actions, history, None)

    return np.concatenate((external, internal, cf_ext, cf_int))

def return_cs_partial_sequence_orginal(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    external_memory_weights = [None]

    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        external_memory_weights.append(possible_memory_weight)

    external = return_all_external_modified_deviations(num_actions, external_memory_weights, prior_legal_actions,prior_actions_in_memory, history)
    internal = return_informed_action(num_actions, history, None)

    cf_ext = return_informed_CF(num_actions, history, None)
    return np.concatenate((external, internal, cf_ext))

def return_twice_informed_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    memory_weights = [None]

    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)

    internal = return_all_internal_modified_deviations(num_actions, memory_weights, prior_legal_actions, prior_actions_in_memory, history)

    cf_int = return_informed_CF(num_actions, history, None)

    return np.concatenate((internal, cf_int))
def return_swap_cf(num_actions, history, prior_legal_actions):
    inf = return_informed_CF(num_actions, history, prior_legal_actions)
    blind  = return_blind_CF(num_actions, history, prior_legal_actions)
    return np.concatenate((inf, blind))

def generate_all_action_permutations(current_stem, remaining_actions):
    if len(remaining_actions) == 0:
        return [np.array(current_stem)]
    else:
        next_actions = remaining_actions[0]
        permutations = []
        for action in next_actions:
            next_stem = current_stem.copy()
            next_stem.append(action)
            next_remaining_actions = remaining_actions[1:]
            prev_permutations = generate_all_action_permutations(next_stem ,next_remaining_actions)
            for i in prev_permutations:
                permutations.append(i)
        return permutations
#Includes identity 
def return_behavourial(num_actions, history, prior_legal_actions):
    deviations = []
    if len(history) == 0:
        internal = return_all_non_identity_internal_deviations(num_actions,[None], [None], history)
        for i in internal:
            deviations.append(i)
    else:
        for deviation_info in range(len(history)):
            prior_possible_memory_actions = generate_all_action_permutations([],prior_legal_actions[:deviation_info+1])
            memory_weights = np.concatenate((np.ones(deviation_info), np.zeros(len(history) - deviation_info)))
            for prior_memory_actions in prior_possible_memory_actions:
                prior_memory_actions = np.concatenate((prior_memory_actions, np.zeros(len(history) - len(prior_memory_actions))))
                for i in range (len(history) - len(prior_memory_actions)):
                    prior_memory_actions.append(0)
                prior_memory_actions_cp = prior_memory_actions.copy()
                internal = return_all_non_identity_internal_deviations(num_actions,[memory_weights], prior_memory_actions_cp, prior_memory_actions_cp)
                for i in internal:
                    deviations.append(i)

    print(deviations)
    return deviations