from Deviation_Types.Deviation import *
import attr
import numpy as np
from Deviation_Types.Swap_Transform import LocalSwapTransform 

def return_blind_action(num_actions, history, prior_legal_actions):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_informed_action(num_actions, history, prior_legal_actions):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_CF(num_actions, history, prior_legal_actions):
    memory_weights = [None]
    prior_actions_in_memory = np.zeros(len(history))
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_informed_CF(num_actions, history, prior_legal_actions):
    memory_weights = [None]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    memory_weights = [None]
    print(history)
    if len(history)>0:
        memory_weights.append(np.ones(len(history)))
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cf_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    memory_weights = [None]
    if len(history)>0:
        memory_weights.append(np.ones(len(history)))
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cs_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    external_memory_weights = [None]

    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        external_memory_weights.append(possible_memory_weight)

    external = return_all_external_modified_deviations(num_actions, external_memory_weights, prior_legal_actions,prior_actions_in_memory, history)
    internal = return_blind_action(num_actions, history, None)

    cf_ext = return_informed_CF(num_actions, history, None)
    cf_int = return_blind_CF(num_actions, history, None)

    return np.concatenate((external, internal, cf_ext, cf_int))

def return_twice_informed_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    memory_weights = [None]

    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)

    internal = return_all_internal_modified_deviations(num_actions, memory_weights, prior_legal_actions, prior_actions_in_memory, history)

    cf_int = return_blind_CF(num_actions, history, None)

    return np.concatenate((internal, cf_int))

    