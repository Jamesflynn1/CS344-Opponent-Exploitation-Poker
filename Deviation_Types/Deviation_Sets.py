from Deviation_Types.Deviation import *
import attr
import numpy as np
from Deviation_Types.Swap_Transform import LocalSwapTransform 

#We pipe in the correct prob values for upto CPS
def return_blind_CF(num_actions, history):
    memory_weights = [None]
    #To achieve *, we use a 0 memory weight instead
    prior_actions_in_memory = np.zeros(len(history))
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_action(num_actions, history):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_informed_CF(num_actions, history):
    memory_weights = [None]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)
    
def return_informed_action(num_actions, history):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_partial_sequence(num_actions, history):
    prior_actions_in_memory = history
    memory_weights = [None]
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cf_partial_sequence(num_actions, history):
    prior_actions_in_memory = history
    memory_weights = [None]
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cf_partial_sequence(num_actions, history):
    prior_actions_in_memory = history
    memory_weights = [None]
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.fill(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

    