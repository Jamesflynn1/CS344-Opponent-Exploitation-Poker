from Deviation import *
import attr
import numpy as np
from Swap_Transform import LocalSwapTransform 

#We pipe in the correct prob values for upto CPS
def return_blind_CF(num_actions, history_length):
    memory_weights = [None]
    #To achieve *, we use a 0 memory weight instead
    prior_actions_in_memory = np.zeros(history_length)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory)

def return_blind_action(num_actions, history_length):
    memory_weights = [np.fill(history_length, 1)]
    prior_actions_in_memory = np.zeros(history_length)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory)

def return_informed_CF(num_actions, player_history, history_length):
    memory_weights = [None]
    prior_actions_in_memory = np.zeros(history_length)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory)
    
def return_informed_action(num_actions, history_length):
    memory_weights = [np.fill(history_length, 1)]
    prior_actions_in_memory = np.zeros(history_length)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory)

def return_blind_partial_sequence(num_actions, history_length):
    prior_actions_in_memory = np.zeros(history_length)
    memory_weights = [None]
    for i in range(history_length):
        possible_memory_weight = np.zeros(history_length)
        possible_memory_weight[0:i] = np.fill(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory)

def return_cf_partial_sequence(num_actions, history_length):
    prior_actions_in_memory = np.zeros(history_length)
    memory_weights = [None]
    for i in range(history_length):
        possible_memory_weight = np.zeros(history_length)
        possible_memory_weight[0:i] = np.fill(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory)

def return_cf_partial_sequence(num_actions, history_length):
    prior_actions_in_memory = np.zeros(history_length)
    memory_weights = [None]
    for i in range(history_length):
        possible_memory_weight = np.zeros(history_length)
        possible_memory_weight[0:i] = np.fill(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory)

    