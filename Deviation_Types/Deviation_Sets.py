from Deviation_Types.Deviation import *
import attr
import numpy as np
from Deviation_Types.Swap_Transform import LocalSwapTransform 

#We pipe in the correct prob values for upto CPS
def return_blind_CF(num_actions, history):
    memory_weights = [None]
    #To achieve *, we use a 0 memory weight instead
    prior_actions_in_memory = np.zeros(len(history))
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_action(num_actions, history):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_informed_CF(num_actions, history):
    memory_weights = [None]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)
    
def return_informed_action(num_actions, history):
    memory_weights = [np.full(len(history), 1)]
    prior_actions_in_memory = history
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_blind_partial_sequence(num_actions, history):
    prior_actions_in_memory = history
    memory_weights = [None]
    print(history)
    if len(history)>0:
        memory_weights.append(np.ones(len(history)))
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_external_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cf_partial_sequence(num_actions, history):
    prior_actions_in_memory = history
    memory_weights = [None]
    if len(history)>0:
        memory_weights.append(np.ones(len(history)))
    for i in range(len(history)):
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        memory_weights.append(possible_memory_weight)
    return return_all_non_identity_internal_deviations(num_actions, memory_weights, prior_actions_in_memory, history)

def return_cs_partial_sequence(num_actions, history, prior_legal_actions):
    prior_actions_in_memory = history
    alt_histories = []
    external_memory_weights = [None]

    for i in range(len(history)):
        for action in prior_legal_actions[i]:
            alt_history = prior_actions_in_memory.copy()
            alt_history[i] = action
            alt_histories.append(alt_history)
        possible_memory_weight = np.zeros(len(history))
        possible_memory_weight[0:i] = np.full(i, 1.0)
        external_memory_weights.append(possible_memory_weight)

    external = return_all_external_modified_deviations(num_actions, external_memory_weights, prior_actions_in_memory, history)
    internal = return_blind_action(num_actions, history)
    cf_ext = return_informed_CF(num_actions, history)
    cf_int = return_blind_CF(num_actions, history)

    