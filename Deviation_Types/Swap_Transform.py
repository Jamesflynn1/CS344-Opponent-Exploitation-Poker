import collections
import attr
import numpy as np


#Returns 
@attr.s
class LocalSwapTransform(object):
    sourceAction = attr.ib()
    targetAction = attr.ib()
    matrix_transform = attr.ib()
    actionsNum = attr.ib()
    is_external = attr.ib()
    
    def __init__(self, target,source,actionsNum, is_external = True):
        self.sourceAction = source
        self.targetAction = target
        self.actionsNum = actionsNum
        self.is_external = is_external
        #A
        if is_external:
            self.sourceAction == None
            self.matrix_transform = np.zeros((actionsNum,actionsNum))
            self.matrix_transform[target] = np.ones(actionsNum)
        else:
            self.matrix_transform = np.eye(actionsNum)
            self.matrix_transform = self.matrix_transform[target][source] = 1
            self.matrix_transform = self.matrix_transform[target][source] = 0
    def __repr__(self) -> str:
        return "Shifting probabilty from Action: "+str(self.sourceAction) +" to Action: "+str(self.targetAction)
        
    def __eq__(self, __o: object) -> bool:
        if self.sourceAction == __o.sourceAction and self.targetAction == __o.targetAction and self.actionsNum == __o.actionsNum:
            return True
        else:
            return False
    def __hash__(self):
        return hash(self.sourceAction, self.targetAction, self.actionsNum, self.is_external)
    #If a pure strategy, a pure strategy will be returned (aka function works for both actions and strategies as input)
    def deviate(self,strategy):
        return self.matrix_transform * strategy
