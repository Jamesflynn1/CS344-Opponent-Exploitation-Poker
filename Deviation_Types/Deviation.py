import collections
import attr
import numpy as np
from Swap_Transform import LocalSwapTransform 

@attr.s
class LocalDeviationWithTimeSelection(object):
    localSwapTransform = attr.ib()

    #Which actions have been forgotten (0) or remembered (1) according to the memory state
    prior_actions_weight = attr.ib()

    #Which actions have been take according to the memory state
    prior_memory_actions = attr.ib()
    
    def __init__(self, target, source, num_actions, prior_actions_weight, prior_memory_actions, is_external):
            self.localSwapTransform = LocalSwapTransform(target, source, num_actions, is_external)
            self.prior_actions_weight = prior_actions_weight
            self.prior_memory_actions = prior_memory_actions

    #If a pure strategy, a pure strategy will be returned (aka function works for both actions and strategies as input)
    def deviate(self,strategy):
        return self.localSwapTransform.deviate(strategy)

    def player_deviation_reach_probability(self, prior_possible_action_probabilities):
        if self.prior_actions_weight == None:
            return 1.0
        memory_action_probabilities = np.zeros(len(self.prior_actions_weight))
        for action in self.prior_memory_actions:
            memory_action_probabilities.append(prior_possible_action_probabilities[action])
        return np.dot(self.prior_actions_weight, memory_action_probabilities)
    def __eq__(self,other):
        if self.localSwapTransform == other.localSwapTransform:
            return True
        else:
            return False
    def __hash__(self):
        return hash(self.localSwapTransform)
    def memory_hash(self):
        return hash(self) + hash(self.prior_actions_weight) + hash(self.prior_actions_weight)

def return_all_non_identity_internal_deviations(num_actions, possible_prior_weights, prior_memory_actions):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            for source in range(num_actions):
                if not source == target:
                    deviations.append(LocalDeviationWithTimeSelection(target, source, num_actions, prior_actions_weight, prior_memory_actions, False))

def return_all_external_deviations(num_actions, possible_prior_weights, prior_memory_actions):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            deviations.append(LocalDeviationWithTimeSelection(target, target, num_actions, prior_actions_weight, prior_memory_actions, True))

def return_identity_deviation(num_actions, possible_prior_weights, prior_memory_actions):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            deviations.append(LocalDeviationWithTimeSelection(target, target, num_actions, prior_actions_weight, prior_memory_actions, False))
