import collections
import attr
import numpy as np
from Deviation_Types.Swap_Transform import LocalSwapTransform 

class LocalDeviationWithTimeSelection(object):
    localSwapTransform = attr.ib()

    #Which actions have been forgotten (0) or remembered (1) according to the memory state
    prior_actions_weight = attr.ib()

    #Which actions have been take according to the memory state
    prior_memory_actions = attr.ib()

    use_unmodified_history = attr.ib()
    
    def __init__(self, target, source, num_actions, prior_actions_weight, prior_memory_actions, is_external, use_unmodified_history = True):
            self.localSwapTransform = LocalSwapTransform(target, source, num_actions, is_external = is_external)
            self.prior_actions_weight = prior_actions_weight
            self.prior_memory_actions = prior_memory_actions
            self.use_unmodified_history = use_unmodified_history

    #If a pure strategy, a pure strategy will be returned (aka function works for both actions and strategies as input)
    def deviate(self,strategy):
        return self.localSwapTransform.deviate(strategy)
    def return_transform_matrix(self):
        return self.localSwapTransform.matrix_transform
    def player_deviation_reach_probability(self, prior_possible_action_probabilities):
        try:
            if self.prior_actions_weight == None:
                return 1.0
            elif self.prior_memory_actions == None:
                return 1.0
        except:
            try:
                if prior_possible_action_probabilities == None:
                    return 1.0
            except:
                try:
                    if self.prior_memory_actions == None:
                        return 1.0
                except:
                    pass

        memory_action_probabilities = np.zeros(len(self.prior_actions_weight))
        #Reconstruct memory probabilities from history provided to the deviation to reach info set and the current memory probs
        if self.use_unmodified_history:
            for state in range(len(self.prior_memory_actions)):
                memory_action_probabilities[state] = (prior_possible_action_probabilities[state][self.prior_memory_actions[state]])
        path_probability = np.multiply(self.prior_actions_weight, memory_action_probabilities)
        return np.prod(path_probability)
    def __eq__(self,other):
        if self.localSwapTransform == other.localSwapTransform:
            return True
        else:
            return False
    def __hash__(self):
        return hash(self.localSwapTransform)
    def memory_hash(self):
        return hash(self) + hash(self.prior_actions_weight) + hash(self.prior_actions_weight)

def return_all_non_identity_internal_deviations(num_actions, possible_prior_weights, prior_memory_actions, history):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            for source in range(num_actions):
                if not source == target:
                    deviations.append(LocalDeviationWithTimeSelection(target, source, num_actions, prior_actions_weight, prior_memory_actions, False))
    return deviations

def return_all_external_deviations(num_actions,  possible_prior_weights, prior_memory_actions, history):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            deviations.append(LocalDeviationWithTimeSelection(target, target, num_actions, prior_actions_weight, prior_memory_actions, True))
    return deviations

def return_identity_deviation(num_actions,  possible_prior_weights, prior_memory_actions, history):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        deviations.append(LocalDeviationWithTimeSelection(0, 0, num_actions, prior_actions_weight, prior_memory_actions, False))
    return deviations
