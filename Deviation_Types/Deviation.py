import collections
import attr
import numpy as np
from Swap_Transform import LocalSwapTransform 

@attr.s
class LocalDeviationWithTimeSelection(object):
    localSwapTransform = attr.ib()

    priorDeviations = attr.ib()

    timeSelectionFunctions = attr.ib()
    
    def __init__(self, target, source, num_actions, prior_actions_weight, is_external):
            self.localSwapTransform = LocalSwapTransform(target, source, num_actions, is_external)
            self.priorDeviations = prior_actions_weight
    #If a pure strategy, a pure strategy will be returned (aka function works for both actions and strategies as input)
    def deviate(self,strategy):
        return self.localSwapTransform.deviate(strategy)

    def player_deviation_reach_probability(self,prior_action_probabilities):
        return np.dot(self.priorDeviations, prior_action_probabilities)

def return_all_non_identity_internal_deviations(num_actions, possible_prior_weights):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            for source in range(num_actions):
                if not source == target:
                    deviations.append(LocalDeviationWithTimeSelection(target, source, num_actions, prior_actions_weight, False))

def return_all_external_deviations(num_actions, possible_prior_weights):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            deviations.append(LocalDeviationWithTimeSelection(target, target, num_actions, prior_actions_weight, True))

def return_identity_deviation(num_actions, possible_prior_weights):
    deviations = []
    for prior_actions_weight in possible_prior_weights:
        for target in range(num_actions):
            deviations.append(LocalDeviationWithTimeSelection(target, target, num_actions, prior_actions_weight, False))
