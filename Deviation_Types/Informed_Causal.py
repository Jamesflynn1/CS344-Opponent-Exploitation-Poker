import collections
import attr
import numpy as np
from Swap_Transform import LocalSwapTransform 


@attr.s
class LocalDeviation(object):
    localSwapTransform = attr.ib()

    priorDeviations = attr.ib()

    timeSelectionFunctions = attr.ib()
    
    def __init__(self, target, source, num_actions, prior_actions_weight, player_history_length):
            self.localSwapTransform = LocalSwapTransform(target, source, num_actions)
            self.priorDeviations = prior_deviations
    #If a pure strategy, a pure strategy will be returned (aka function works for both actions and strategies as input)
    def deviate(self,strategy):
        return self.localSwapTransform.deviate(strategy)

    def player_deviation_reach_probability(self,prior_action_probabilities):
        return np.dot(self.priorDeviations, prior_action_probabilities)
def rt1(t):
    return 1
class informedCausalDeviation(deviation):

    def __init__(self, targetInfoSet, devationAction, deviationTargetAction):
         self.targetInfoSet = targetInfoSet
         self.deviationAction = devationAction
         self.deviationTargetAction = deviationTargetAction
         self.timeSelectionFunctions = [rt1]

         self.targetAction = None
         self.deviationInfoSet = None
         self.deviationInfoSet = None
         

    def deviate(self, infoSetNode, strategy):
        #print(infoSetNode)
        deviationStrategy = strategy.copy()
        #print(deviationStrategy)
        if infoSetNode == self.targetInfoSet:
            #print(len(infoSetNode.legal_actions))
            for i in infoSetNode.legal_actions:
                if self.deviationTargetAction == i:
                    if not self.deviationAction in infoSetNode.legal_actions:
                        print("errpr")
                    deviationStrategy[self.deviationAction] = deviationStrategy[i] + deviationStrategy[self.deviationAction]
                    deviationStrategy[i] = 0
                else:
                    deviationStrategy[i] = deviationStrategy[i] 
        #print(" TEST " + str(list(deviationStrategy.values())))
        return list(deviationStrategy.values())

#Returns all deviations NOW relizable on an infomation state
def returnInformedCausalDeviation(info_state,info_state_node):
    deviationSet = []
    for target_action in info_state_node.legal_actions:
        for deviation_action in info_state_node.legal_actions:
            if not target_action == deviation_action:
                deviationSet.append(informedCausalDeviation(info_state_node, deviation_action,target_action))
    return deviationSet

def returnInformedCausalDeviation2(info_state,info_state_node, player_history_length):
    deviationSet = []
    deviation_weighting_set = []
    for i in range(len(player_history_length)):
        weighting_set = []
        for c in range(len(player_history_length)):
            if c>i:
                weighting_set.append(1)
            else:
                weighting_set.append(0)
    #0 Corresponds to the player taking that action with certainty at that point, 1 Corresponds to taking that action with orginal probability
    for source_action in range(len(info_state_node.legal_actions)):
        for target_action in range(len(info_state_node.legal_actions)):
            if not target_action == source_action:
                for prior_actions_weight in deviation_weighting_set:
                    deviationSet.append(LocalDeviation(target_action,target_action, prior_actions_weight, player_history_length))
    return deviationSet