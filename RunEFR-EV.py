# Copyright 2019 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Example use of the CFR algorithm on Kuhn Poker."""
import pandas as pd
import time
import sys


import EFR
from multiprocessing import Pool
from open_spiel.python.algorithms import expected_game_score
from collections import defaultdict

import StoreTabularPolicy
import pyspiel

FL_game = 'leduc_poker'
FL_iterations = 10
FL_players = 2
FL_Runname = "Test run"

try:
  FL_Runname = sys.argv[1]
except:
  pass
try:
  FL_iterations = int(sys.argv[2])
  print(FL_iterations)
except:
  pass
try:
  FL_deviation = sys.argv[3]
except:
  pass
def iteration_update(efr_solver):
  efr_solver.evaluate_and_update_policy()
header = ['Iteration', 'Deviation Set', 'Average Expected Value']#, 'Average Payoff', 'Value compared to uniform']
efr_data = []
esxpected_values = defaultdict(float)

efr_solvers = []
deviation_types = ["blind action", "informed action", "blind cf", "informed cf", "bps", "cfps", "csps", "tips", "bhv"]
game = pyspiel.load_game(FL_game)
for deviation_type in deviation_types:
  efr_solvers.append(EFR.EFRSolver(game, deviation_type))


for iteration in range(FL_iterations):
  #Batch update all EFR
  with Pool(processes=8) as pool:
    pool.map(iteration_update, efr_solvers)
  expected_values = defaultdict(float)
  for i in range(len(deviation_types)):
    for h in range(len(deviation_types)):
      #Check if correct
      if i == h:
        continue
      player_one = efr_solvers[i].average_policy()
      player_two = efr_solvers[h].average_policy()
      expected_value = expected_game_score.policy_value(game.new_initial_state(), [player_one, player_two])
      expected_values[deviation_types[i]] += expected_value[0]
      expected_values[deviation_types[h]] += expected_value[1]
  #Normalise to find avg as we have added 2*devition types expected values
  for deviation_type in deviation_types:
    expected_values[deviation_type] = expected_values[deviation_type] / (2*len(deviation_types))
    efr_dev_iteration_data = [iteration]
    efr_dev_iteration_data.append(deviation_type)
    efr_dev_iteration_data.append(expected_values[deviation_type])
    efr_data.append(efr_dev_iteration_data)


EFR_data = pd.DataFrame(efr_data, columns=header)

EFR_data.to_csv(FL_Runname+'EFR.csv', index=False)
 